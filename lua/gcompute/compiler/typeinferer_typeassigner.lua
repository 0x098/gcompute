local self = {}GCompute.TypeInfererTypeAssigner = GCompute.MakeConstructor (self, GCompute.ASTVisitor)function self:ctor (compilationUnit)	self.CompilationUnit = compilationUnitendfunction self:VisitExpression (expression)	if expression:GetType () then		if expression:GetType ():IsDeferredNameResolution () then			-- There shouldn't be any DeferredNameResolutions here!			self.CompilationUnit:Error ("Pre-assigned type of " .. expression:ToString () .. " should not be a DeferredNameResolution! (" .. expression:GetType ():ToString () .. ")")		elseif expression:GetType ():IsTypeDefinition () then			self.CompilationUnit:Debug ("Pre-assigned type of " .. expression:ToString () .. " is " .. expression:GetType ():GetFullName ())		else			self.CompilationUnit:Debug ("Pre-assigned type of " .. expression:ToString () .. " is " .. expression:GetType ():ToString ())		end		return	end		if expression:Is ("Identifier") then		local result = expression.ResolutionResults:GetResult (1)		if result then			local definition = result.Result			local metadata = result.Metadata			if metadata:GetMemberType () == GCompute.MemberTypes.Method then				if definition:GetFunctionCount () == 1 then					expression:SetType (definition:GetFunction (1):GetType ())				else					-- overload resolution					local inferredType = GCompute.InferredType ()					expression:SetType (inferredType)					inferredType:ImportFunctionTypes (definition)				end			elseif metadata:GetMemberType () == GCompute.MemberTypes.Type then				expression:SetType (GCompute.DeferredNameResolution ("Type"):Resolve ())			else				expression:SetType (GCompute.ReferenceType (definition:GetType ()))			end		else			expression:SetType (GCompute.NullType ())			self.CompilationUnit:Error ("Cannot find \"" .. expression:ToString () .. "\".", expression:GetSourceLine (), expression:GetSourceCharacter ())		end	elseif expression:Is ("FunctionCall") then		expression:SetType (GCompute.InferredType ())				local leftExpression = expression:GetLeftExpression ()		local leftType = leftExpression:GetType ()		if leftType:IsInferredType () then		elseif leftType:IsFunctionType () then			expression:SetType (leftExpression:GetType ():GetReturnType ())		else			expression:SetType (GCompute.NullType ())			self.CompilationUnit:Error ("Cannot perform a function call on " .. leftExpression:ToString () .. " because it is not a function.", expression:GetSourceLine (), expression:GetSourceCharacter ())		end	elseif expression:Is ("MemberFunctionCall") then		local leftExpression = expression:GetLeftExpression ()		local leftType = leftExpression:GetType ()		local leftTypeDefinition = nil		if leftType:IsDeferredNameResolution () then			leftType = leftType:GetObject ()		end				if leftType and leftType:UnwrapReference () then			leftTypeDefinition = leftType:UnwrapReference ():GetTypeDefinition ()		end		local functionType = nil				-- determine the function type		if not leftType then		elseif leftType:IsInferredType () then		elseif leftTypeDefinition then			local definition = leftTypeDefinition:GetMember (expression:GetMemberName ())			-- memberDefinition should be an OverloadedFunctionDefinition			if definition then				if definition:IsOverloadedFunctionDefinition () then					if definition:GetFunctionCount () == 1 then						functionType = definition:GetFunction (1):GetType ()					else						functionType = GCompute.InferredType ()						functionType:ImportFunctionTypes (definition)					end				else					self.CompilationUnit:Error (leftExpression:GetType ():GetFullName () .. "." .. expression:GetMemberName () .. " is not a function and cannot be called.", expression:GetSourceLine (), expression:GetSourceCharacter ())				end			else				self.CompilationUnit:Error (leftExpression:GetType ():GetFullName () .. " has no member called " .. expression:GetMemberName (), expression:GetSourceLine (), expression:GetSourceCharacter ())			end		else			self.CompilationUnit:Error ("Fail.", expression:GetSourceLine (), expression:GetSourceCharacter ())		end				if functionType then			self.CompilationUnit:Debug ("Type of " .. leftExpression:ToString () .. ":" .. expression:GetMemberName () .. " is " .. functionType:ToString ())		end				if functionType and functionType:IsFunctionType () then			expression:SetType (functionType:GetReturnType ())		else			expression:SetType (GCompute.NullType ())		end	elseif expression:Is ("BinaryOperator") then		--[[			Assignment				<left> & = <right>					Either:						Overloaded assignment function (=)							<base left>::operator= (<base right>)							operator= (<ref base left>, <base right>)						Default assignment (=)							<left> == <base right>				<left> & [op]= <right>					Either:						Overloaded operator-assignment function ([op]=)						Overloaded operator then assignment ([op] then =)		]]		local operator = expression:GetOperator ()		if operator == "+" then			self:ResolveOperatorCall (expression, "operator+", { expression:GetLeftExpression (), expression:GetRightExpression () })		else		end	elseif expression:Is ("BooleanLiteral") then		expression:SetType (expression:GetType () or GCompute.DeferredNameResolution ("Boolean"):Resolve ())	elseif expression:Is ("NumericLiteral") then		expression:SetType (expression:GetType () or GCompute.DeferredNameResolution ("Number"):Resolve ())	elseif expression:Is ("StringLiteral") then		expression:SetType (expression:GetType () or GCompute.DeferredNameResolution ("String"):Resolve ())	else		expression:SetType (GCompute.InferredType ())	end		if expression:GetType () then		self.CompilationUnit:Debug ("Type of " .. expression:ToString () .. " is " .. expression:GetType ():ToString ())	else		self.CompilationUnit:Debug (expression:ToString () .. " has no type.")	endendfunction self:ResolveOperatorCall (astNode, functionName, arguments)	local functionResolutionResult = GCompute.FunctionResolutionResult ()	astNode.FunctionResolutionResult = functionResolutionResult	self.CompilationUnit:Debug ("Resolving " .. astNode:ToString () .. ": " .. functionResolutionResult:ToString ())end